ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
text(x = trim_at_time / 4, y = y_lim_max, labels = col_name, pos = 1)
if (gc_fit$model=="") {
gc_fit$model<-rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1)
lines(gc_fit$data$t, rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1), col = "indianred3")
}
else #I added 'if...else' for data where no model was fit plots line at y=0
lines(gc_fit$data$t, predict(gc_fit$model), col = "indianred3")
}
}
dev.off()
dur
as.numeric(dur[[length(dur)]])
d<-final #renames our data to match growthcurver's provided script
num_analyses <- length(names(d)) - 1
d_gc <- data.frame(sample = character(num_analyses),
k = numeric(num_analyses),
n0  = numeric(num_analyses),
r = numeric(num_analyses),
t_mid = numeric(num_analyses),
t_gen = numeric(num_analyses),
auc_l = numeric(num_analyses),
auc_e = numeric(num_analyses),
sigma = numeric(num_analyses),
stringsAsFactors = FALSE)
trim_at_time<- as.numeric(dur[[length(dur)]])#set our preferred plotting range based on tdif
pdf("results/LAA-E2_growthcurver_r.pdf", height = 8.5, width = 11)
par(mfrow = c(8,12))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(d[,setdiff(names(d), "time")]) - min(d[,setdiff(names(d), "time")])
n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(d)) {
# Don't process the column called "time".
# It contains time and not absorbance data.
if (col_name != "time") {
# Create a temporary data frame that contains just the time and current col
d_loop <- d[, c("time", col_name)]
# Do the background correction.
# Background correction option 1: subtract the minimum value in a column
#                                 from all measurements in that column
min_value <- min(d_loop[, col_name])
d_loop[, col_name] <- d_loop[, col_name] - min_value
# Background correction option 2: subtract the mean value of blank wells
#                                 over the course the experiment
#                                 (Replace B2, D8, G11 with the column
#                                  names of your media-only wells)
#d$blank <- apply(d[, c("B2", "D8", "G11")], 1, mean)
#d$A1 <- d$A1 - d$blank
# Now, call Growthcurver to calculate the metrics using SummarizeGrowth
gc_fit <- SummarizeGrowth(data_t = d_loop[, "time"],
data_n = d_loop[, col_name],
t_trim = trim_at_time,
bg_correct = "none")
# Now, add the metrics from this column to the next row (n) in the
# output data frame, and increment the row counter (n)
d_gc$sample[n] <- col_name
d_gc[n, 2:9] <- c(gc_fit$vals$k,
gc_fit$vals$n0,
gc_fit$vals$r,
gc_fit$vals$t_mid,
gc_fit$vals$t_gen,
gc_fit$vals$auc_l,
gc_fit$vals$auc_e,
gc_fit$vals$sigma)
n <- n + 1
# Finally, plot the raw data and the fitted curve
# Here, I'll just print some of the data points to keep the file size smaller
n_obs <- length(gc_fit$data$t)
idx_to_plot <- 1:20 / 20 * n_obs
plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot],
pch = 20,
xlim = c(0, trim_at_time),
ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
text(x = trim_at_time / 4, y = y_lim_max, labels = col_name, pos = 1)
if (gc_fit$model=="") {
gc_fit$model<-rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1)
lines(gc_fit$data$t, rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1), col = "indianred3")
}
else #I added 'if...else' for data where no model was fit plots line at y=0
lines(gc_fit$data$t, predict(gc_fit$model), col = "indianred3")
}
}
dev.off()
d<-final #renames our data to match growthcurver's provided script
num_analyses <- length(names(d)) - 1
d_gc <- data.frame(sample = character(num_analyses),
k = numeric(num_analyses),
n0  = numeric(num_analyses),
r = numeric(num_analyses),
t_mid = numeric(num_analyses),
t_gen = numeric(num_analyses),
auc_l = numeric(num_analyses),
auc_e = numeric(num_analyses),
sigma = numeric(num_analyses),
stringsAsFactors = FALSE)
trim_at_time<- as.numeric(dur[[length(dur)]])#set our preferred plotting range based on tdif
d_gc %>% ggplot()+geom_point()
plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot],
pch = 20,
xlim = c(0, trim_at_time),
ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
text(x = trim_at_time / 4, y = y_lim_max, labels = col_name, pos = 1)
knitr::opts_knit$set(root.dir = 'C:/Users/alexg/Google Drive/05-Proyectos/restlab_workshop/01-MarianaRius-Growthcurver/')
#Or setwd()
#setwd('C:/Users/alexg/Google Drive/05-Proyectos/restlab_workshop/01-MarianaRius-Growthcurver/')
install.packages("tidyverse")
options(stringsAsFactors = F)
#total wells
tw<-96
#filename
fn<-"data/LAA-E2.xlsx"
#replicates?
x<-3
#number of antibiotic concentrations
nc<-12
#number of strains #JUST AURLI
ns<-1
library("tidyverse")
library("tidyverse")
library("readxl")
sheets <- excel_sheets(fn)
exceltable <- sheets  %>%
as.list() %>%
map(read_excel,path=fn,col_names = FALSE) %>%
map(as_tibble)
names(exceltable) <- paste("t-", sheets, sep = "")
sheetslist <- exceltable %>%
map(slice,27:34) %>% #This selects the OD values
map(select,-1)
for (i in 1:length(sheetslist)){
colnames(sheetslist[[i]]) <- as.character(c(paste0(0,1:9),10:12))
sheetslist[[i]]$rows <- LETTERS[1:8]
sheetslist[[i]] <- sheetslist[[i]] %>% gather(1:12,key="column",value="OD")
}
sheetslist <- sheetslist %>%
map(as.tibble) %>%
map(mutate,well=paste0(rows,column)) %>%
map(mutate,OD=as.numeric(OD))
sheetslist[[1]]
#Select only the first 3 rows
allSheets <- sheetslist %>%
map(filter,rows==c("A","B","C")) %>%
map(arrange,well)
allSheets[[1]]
#calculate difference in time
timelist <- exceltable  %>%
map(select,2) %>%
map(slice,23:24)
vec <- timelist %>% unlist()
vec <- vec[!is.na(vec)]
library(lubridate)
time <- data.frame(ID=sheets,
time = mdy_hms(vec)) %>%
as_tibble() %>%
arrange(time)%>%
mutate(dur = time - time[1])
dur<-time$dur %>% map_dfc(dseconds) %>% as.list()
time
allSheets1 <- allSheets %>%
map(select,well,OD)%>%
map(spread,key="well",value="OD")
df <- bind_rows(allSheets1, .id = "ID") %>% arrange(ID) %>% as.data.frame()
t <- time %>% arrange(ID)%>% select(-ID) %>% as.data.frame()
final <- cbind(t,df) %>%  as.tibble() %>% select(-ID,-time) %>%  rename(time=dur) %>% mutate(time=as.numeric(time))%>%  as.data.frame()
final <- cbind(t,df) %>%  as_tibble() %>% select(-ID,-time) %>%  rename(time=dur) %>% mutate(time=as.numeric(time))%>%  as.data.frame()
head(final)
library("growthcurver")
gc_out <- SummarizeGrowthByPlate(final)
head(gc_out)
write.csv(gc_out,file="results/aurli_growthcurver_output.csv")
save(gc_out,file="results/aurli_growthcurver_output.rda")
d<-final #renames our data to match growthcurver's provided script
num_analyses <- length(names(d)) - 1
d_gc <- data.frame(sample = character(num_analyses),
k = numeric(num_analyses),
n0  = numeric(num_analyses),
r = numeric(num_analyses),
t_mid = numeric(num_analyses),
t_gen = numeric(num_analyses),
auc_l = numeric(num_analyses),
auc_e = numeric(num_analyses),
sigma = numeric(num_analyses),
stringsAsFactors = FALSE)
trim_at_time<- as.numeric(dur[[length(dur)]])#set our preferred plotting range based on tdif
par(mfrow = c(8,12))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(d[,setdiff(names(d), "time")]) - min(d[,setdiff(names(d), "time")])
n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(d)) {
# Don't process the column called "time".
# It contains time and not absorbance data.
if (col_name != "time") {
# Create a temporary data frame that contains just the time and current col
d_loop <- d[, c("time", col_name)]
# Do the background correction.
# Background correction option 1: subtract the minimum value in a column
#                                 from all measurements in that column
min_value <- min(d_loop[, col_name])
d_loop[, col_name] <- d_loop[, col_name] - min_value
# Background correction option 2: subtract the mean value of blank wells
#                                 over the course the experiment
#                                 (Replace B2, D8, G11 with the column
#                                  names of your media-only wells)
#d$blank <- apply(d[, c("B2", "D8", "G11")], 1, mean)
#d$A1 <- d$A1 - d$blank
# Now, call Growthcurver to calculate the metrics using SummarizeGrowth
gc_fit <- SummarizeGrowth(data_t = d_loop[, "time"],
data_n = d_loop[, col_name],
t_trim = trim_at_time,
bg_correct = "none")
# Now, add the metrics from this column to the next row (n) in the
# output data frame, and increment the row counter (n)
d_gc$sample[n] <- col_name
d_gc[n, 2:9] <- c(gc_fit$vals$k,
gc_fit$vals$n0,
gc_fit$vals$r,
gc_fit$vals$t_mid,
gc_fit$vals$t_gen,
gc_fit$vals$auc_l,
gc_fit$vals$auc_e,
gc_fit$vals$sigma)
n <- n + 1
# Finally, plot the raw data and the fitted curve
# Here, I'll just print some of the data points to keep the file size smaller
n_obs <- length(gc_fit$data$t)
idx_to_plot <- 1:20 / 20 * n_obs
plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot],
pch = 20,
xlim = c(0, trim_at_time),
ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
text(x = trim_at_time / 4, y = y_lim_max, labels = col_name, pos = 1)
if (gc_fit$model=="") {
gc_fit$model<-rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1)
lines(gc_fit$data$t, rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1), col = "indianred3")
}
else #I added 'if...else' for data where no model was fit plots line at y=0
lines(gc_fit$data$t, predict(gc_fit$model), col = "indianred3")
}
}
pca_gc_out <- as_data_frame(gc_out)
# Prepare the gc_out data for the PCA
rownames(pca_gc_out) <- pca_gc_out$sample
# Do the PCA
pca.res <- prcomp(pca_gc_out %>% select(k:sigma), center=TRUE, scale=TRUE)
# Plot the results
as_data_frame(list(PC1=pca.res$x[,1],
PC2=pca.res$x[,2],
samples = rownames(pca.res$x))) %>%
ggplot(aes(x=PC1,y=PC2, label=samples)) +
geom_text(size = 3)
df <- bind_rows(allSheets1, .id = "ID") %>%
arrange(ID) %>%
as.data.frame()
t <- time %>%
arrange(ID)%>%
select(-ID) %>%
as.data.frame()
final <- cbind(t,df) %>%
as_tibble() %>%
select(-ID,-time) %>%
rename(time=dur) %>%
mutate(time=as.numeric(time))%>%
as.data.frame()
dur<-time$dur %>%
map_dfc(dseconds)
time
trim_at_time<- as.numeric(dur[length(dur)])#set our preferred plotting range based on tdif
d_gc <- data.frame(sample = character(num_analyses),
k = numeric(num_analyses),
n0  = numeric(num_analyses),
r = numeric(num_analyses),
t_mid = numeric(num_analyses),
t_gen = numeric(num_analyses),
auc_l = numeric(num_analyses),
auc_e = numeric(num_analyses),
sigma = numeric(num_analyses),
stringsAsFactors = FALSE)
d<-final #renames our data to match growthcurver's provided script
num_analyses <- length(names(d)) - 1
d_gc <- data.frame(sample = character(num_analyses),
k = numeric(num_analyses),
n0  = numeric(num_analyses),
r = numeric(num_analyses),
t_mid = numeric(num_analyses),
t_gen = numeric(num_analyses),
auc_l = numeric(num_analyses),
auc_e = numeric(num_analyses),
sigma = numeric(num_analyses),
stringsAsFactors = FALSE)
d_gc
trim_at_time<- as.numeric(dur[length(dur)])#set our preferred plotting range based on tdif
n <- 1    # keeps track of the current row in the output data frame
plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot],
pch = 20,
xlim = c(0, trim_at_time),
ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot],
pch = 20,
xlim = c(0, trim_at_time),
ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
d_gc
gc_out
d<-final #renames our data to match growthcurver's provided script
num_analyses <- length(names(d)) - 1
d_gc <- data.frame(sample = character(num_analyses),
k = numeric(num_analyses),
n0  = numeric(num_analyses),
r = numeric(num_analyses),
t_mid = numeric(num_analyses),
t_gen = numeric(num_analyses),
auc_l = numeric(num_analyses),
auc_e = numeric(num_analyses),
sigma = numeric(num_analyses),
stringsAsFactors = FALSE)
trim_at_time<- as.numeric(dur[length(dur)])#set our preferred plotting range based on tdif
#pdf("results/LAA-E2_growthcurver_r.pdf", height = 8.5, width = 11)
par(mfrow = c(8,12))
par(mar = c(0.25,0.25,0.25,0.25))
y_lim_max <- max(d[,setdiff(names(d), "time")]) - min(d[,setdiff(names(d), "time")])
n <- 1    # keeps track of the current row in the output data frame
for (col_name in names(d)) {
# Don't process the column called "time".
# It contains time and not absorbance data.
if (col_name != "time") {
# Create a temporary data frame that contains just the time and current col
d_loop <- d[, c("time", col_name)]
# Do the background correction.
# Background correction option 1: subtract the minimum value in a column
#                                 from all measurements in that column
min_value <- min(d_loop[, col_name])
d_loop[, col_name] <- d_loop[, col_name] - min_value
# Background correction option 2: subtract the mean value of blank wells
#                                 over the course the experiment
#                                 (Replace B2, D8, G11 with the column
#                                  names of your media-only wells)
#d$blank <- apply(d[, c("B2", "D8", "G11")], 1, mean)
#d$A1 <- d$A1 - d$blank
# Now, call Growthcurver to calculate the metrics using SummarizeGrowth
gc_fit <- SummarizeGrowth(data_t = d_loop[, "time"],
data_n = d_loop[, col_name],
t_trim = trim_at_time,
bg_correct = "none")
# Now, add the metrics from this column to the next row (n) in the
# output data frame, and increment the row counter (n)
d_gc$sample[n] <- col_name
d_gc[n, 2:9] <- c(gc_fit$vals$k,
gc_fit$vals$n0,
gc_fit$vals$r,
gc_fit$vals$t_mid,
gc_fit$vals$t_gen,
gc_fit$vals$auc_l,
gc_fit$vals$auc_e,
gc_fit$vals$sigma)
n <- n + 1
# Finally, plot the raw data and the fitted curve
# Here, I'll just print some of the data points to keep the file size smaller
n_obs <- length(gc_fit$data$t)
idx_to_plot <- 1:20 / 20 * n_obs
plot(gc_fit$data$t[idx_to_plot], gc_fit$data$N[idx_to_plot],
pch = 20,
xlim = c(0, trim_at_time),
ylim = c(0, y_lim_max),
cex = 0.6, xaxt = "n", yaxt = "n")
text(x = trim_at_time / 4, y = y_lim_max, labels = col_name, pos = 1)
if (gc_fit$model=="") {
gc_fit$model<-rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1)
lines(gc_fit$data$t, rep(0,length(tdif[1:grep(trim_at_time, tdif)])-1), col = "indianred3")
}
else #I added 'if...else' for data where no model was fit plots line at y=0
lines(gc_fit$data$t, predict(gc_fit$model), col = "indianred3")
}
}
#dev.off()
knitr::opts_knit$set(root.dir = 'C:/Users/alexg/Google Drive/05-Proyectos/restlab_workshop/01-MarianaRius-Growthcurver/')
#Or setwd()
#setwd('C:/Users/alexg/Google Drive/05-Proyectos/restlab_workshop/01-MarianaRius-Growthcurver/')
library("tidyverse")
library("readxl")
sheets <- excel_sheets(fn)
exceltable <- sheets  %>%
as.list() %>%
map(read_excel,path=fn,col_names = FALSE) %>%
map(as_tibble)
names(exceltable) <- paste("t-", sheets, sep = "")
sheetslist <- exceltable %>%
map(slice,27:34) %>% #This selects the OD values
map(select,-1)
for (i in 1:length(sheetslist)){
colnames(sheetslist[[i]]) <- as.character(c(paste0(0,1:9),10:12))
sheetslist[[i]]$rows <- LETTERS[1:8]
sheetslist[[i]] <- sheetslist[[i]] %>% gather(1:12,key="column",value="OD")
}
sheetslist <- sheetslist %>%
map(as.tibble) %>%
map(mutate,well=paste0(rows,column)) %>%
map(mutate,OD=as.numeric(OD))
sheetslist[[1]]
#Select only the first 3 rows
allSheets <- sheetslist %>%
map(filter,rows==c("A","B","C")) %>%
map(arrange,well)
allSheets[[1]]
#calculate difference in time
timelist <- exceltable  %>%
map(select,2) %>%
map(slice,23:24)
vec <- timelist %>%
unlist()
vec <- vec[!is.na(vec)]
library(lubridate)
time <- data.frame(ID=sheets,
time = mdy_hms(vec)) %>%
as_tibble() %>%
arrange(time)%>%
mutate(dur = time - time[1])
dur<-time$dur %>%
map_dfc(dseconds)
time
allSheets1 <- allSheets %>%
map(select,well,OD)%>%
map(spread,key="well",value="OD")
df <- bind_rows(allSheets1, .id = "ID") %>%
arrange(ID) %>%
as.data.frame()
t <- time %>%
arrange(ID)%>%
select(-ID) %>%
as.data.frame()
final <- cbind(t,df) %>%
as_tibble() %>%
select(-ID,-time) %>%
rename(time=dur) %>%
mutate(time=as.numeric(time))%>%
as.data.frame()
head(final)
final %>% as_tibble() %>%
gather(key = "ID",value="OD")
final %>% as_tibble() %>%
spread(key = "ID",value="OD")
final %>% as_tibble() %>%
gather(2:,key = "ID",value="OD")
final %>% as_tibble() %>%
gather(2:dim(final)[2],key = "ID",value="OD")
table1 <- final %>% as_tibble() %>%
gather(2:dim(final)[2],key = "ID",value="OD")
table1 %>% ggplot()
table1
table1 %>% ggplot(aes(x=time,y=OD))
table1 %>% ggplot(aes(x=time,y=OD))+
facet_wrap(.~ID)
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
facet_wrap(.~ID)
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
theme_minimal()
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_grid()+
theme_minimal()
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_grid(.~ID)+
theme_minimal()
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()+
geom_smooth()
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()+
geom_smooth(se=FALSE)
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()+
geom_smooth(se=FALSE)+
ggtitle("Results from out experiment")
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()+
geom_smooth(se=FALSE)+
labs(title = "Growth Experiments",
subtitle = "Plot of OD by well",
caption = "Data source: LAA-E2.xlsx")
table1 %>% ggplot(aes(x=time,y=OD,color=ID))+
geom_point()+
facet_wrap(.~ID)+
theme_minimal()+
geom_smooth(se=FALSE)+
labs(title = "Growth Experiments",
subtitle = "Plots of Optical Density as a function of time",
caption = "Data source: LAA-E2.xlsx")
